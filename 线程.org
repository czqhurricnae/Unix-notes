* 线程基础
** 连接(join)已终止的线程

#+BEGIN_SRC C 
  #include <pthread.h>

  int pthread_join(pthread_t thread, void **retval);
#+END_SRC
函数pthread_join()等待由thread标识的线程终止, 如果线程已终止, pthread_join()
会立即返回.
若retval为一非空指针, 将保存线程终止时返回值得拷贝, 该返回值亦即线程调用
return或pthread_exit()时所指定的值.

#+BEGIN_SRC C :includes <stdio.h>  "/Users/c/Unix/error_functions.c" :results output list :exports both
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static void *threadFunc(void *arg)
  {
      char *s = (char *)arg;
      printf("%s", s);
      return (void *)strlen(s);
  }

  int main(int argc, char *argv[])
  {
      pthread_t t1;
      void *res;
      int s;

      s = pthread_create(&t1, NULL, threadFunc, "Hello World\n");
      if (s != 0)
      {
          errExitEN(s, "pthread_create");
      }

      printf("Message from main()\n");
      s = pthread_join(t1, &res);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("Thread returned %ld\n", (long)res);

      exit(EXIT_SUCCESS);
      return 0;
  }
#+END_SRC

#+RESULTS:
: - Message from main()
: - Hello World
: - Thread returned 12

** 使用分离属性创建线程

#+BEGIN_SRC C :includes <stdio.h>  "/Users/c/Unix/error_functions.c" :results output list :exports both
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static void *threadFunc(void *arg)
  {
      char *s = (char *)arg;
      printf("%s", s);
      return (void *)strlen(s);
  }

  int main(int argc, char *argv[])
  {
      pthread_t thr;
      pthread_attr_t attr;
      int s;
      void *res;

      s = pthread_attr_init(&attr);
      if (s != 0)
      {
          errExitEN(s, "pthread_attr_init");
      }

      s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
      if ( s != 0)
      {
          errExitEN(s, "pthread_attr_setdetachstate");
      }

      s = pthread_create(&thr, &attr, threadFunc, (void *) 1);
      if ( s != 0)
      {
          errExitEN(s, "pthread_create");
      }

      printf("Message from main()\n");
      s = pthread_join(thr, &res);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("Thread returned %ld\n", (long)res);

      s = pthread_attr_destroy(&attr);
      if ( s != 0)
      {
          errExitEN(s, "pthread_destroy");
      }

      printf("hello world\n");
      exit(EXIT_SUCCESS);

      return 0;
  }
#+END_SRC

#+RESULTS:

** pthread_join(pthread_self(), NULL)

#+BEGIN_SRC C :includes <stdio.h>  "/Users/c/Unix/error_functions.c" 
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static void *threadFunc(void *arg)
  {
      char *s = (char *)arg;
      printf("%s", s);
      return (void *)strlen(s);
  }

  int main(int argc, char *argv[])
  {
      void *res;
      int s;

      printf("Message from main()\n");

      s = pthread_join(pthread_self(), &res);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("Thread returned %ld\n", (long)res);

      exit(EXIT_SUCCESS);
  }
#+END_SRC

#+RESULTS:
Message from main()
ERROR [EDEADLK Resource deadlock avoided] pthread_join

注意:pthread_self后需加括号().
