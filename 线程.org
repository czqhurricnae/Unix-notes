* 线程基础
** 连接(join)已终止的线程

#+BEGIN_SRC C 
  #include <pthread.h>

  int pthread_join(pthread_t thread, void **retval);
#+END_SRC
函数pthread_join()等待由thread标识的线程终止, 如果线程已终止, pthread_join()
会立即返回.
若retval为一非空指针, 将保存线程终止时返回值得拷贝, 该返回值亦即线程调用
return或pthread_exit()时所指定的值.

#+BEGIN_SRC C :includes <stdio.h>  "/Users/c/Unix/error_functions.c" :results output list :exports both
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static void *threadFunc(void *arg)
  {
      char *s = (char *)arg;
      printf("%s", s);
      return (void *)strlen(s);
  }

  int main(int argc, char *argv[])
  {
      pthread_t t1;
      void *res;
      int s;

      s = pthread_create(&t1, NULL, threadFunc, "Hello World\n");
      if (s != 0)
      {
          errExitEN(s, "pthread_create");
      }

      printf("Message from main()\n");
      s = pthread_join(t1, &res);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("Thread returned %ld\n", (long)res);

      exit(EXIT_SUCCESS);
      return 0;
  }
#+END_SRC

#+RESULTS:
: - Message from main()
: - Hello World
: - Thread returned 12

** 使用分离属性创建线程

#+BEGIN_SRC C :includes <stdio.h>  "/Users/c/Unix/error_functions.c" :results output list :exports both
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static void *threadFunc(void *arg)
  {
      char *s = (char *)arg;
      printf("%s", s);
      return (void *)strlen(s);
  }

  int main(int argc, char *argv[])
  {
      pthread_t thr;
      pthread_attr_t attr;
      int s;
      void *res;

      s = pthread_attr_init(&attr);
      if (s != 0)
      {
          errExitEN(s, "pthread_attr_init");
      }

      s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
      if ( s != 0)
      {
          errExitEN(s, "pthread_attr_setdetachstate");
      }

      s = pthread_create(&thr, &attr, threadFunc, (void *) 1);
      if ( s != 0)
      {
          errExitEN(s, "pthread_create");
      }

      printf("Message from main()\n");
      s = pthread_join(thr, &res);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("Thread returned %ld\n", (long)res);

      s = pthread_attr_destroy(&attr);
      if ( s != 0)
      {
          errExitEN(s, "pthread_destroy");
      }

      printf("hello world\n");
      exit(EXIT_SUCCESS);

      return 0;
  }
#+END_SRC

#+RESULTS:

** pthread_join(pthread_self(), NULL)

#+BEGIN_SRC C :includes <stdio.h>  "/Users/c/Unix/error_functions.c" 
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static void *threadFunc(void *arg)
  {
      char *s = (char *)arg;
      printf("%s", s);
      return (void *)strlen(s);
  }

  int main(int argc, char *argv[])
  {
      void *res;
      int s;

      printf("Message from main()\n");

      s = pthread_join(pthread_self(), &res);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("Thread returned %ld\n", (long)res);

      exit(EXIT_SUCCESS);
  }
#+END_SRC

#+RESULTS:
Message from main()
ERROR [EDEADLK Resource deadlock avoided] pthread_join

注意:pthread_self后需加括号().

* 线程同步

#+headers: :cmdline "1000000"
#+BEGIN_SRC C :includes <stdio.h> "/Users/c/Unix/error_functions.c" "/Users/c/Unix/get_num.c" :results output list :exports both
  /* thread_incr.c

     This program employs two POSIX threads that increment the same global
     variable, without using any synchronization method. As a consequence,
     updates are sometimes lost.

     See also thread_incr_mutex.c.
  ,*/
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static volatile int glob = 0;   /* "volatile" prevents compiler optimizations
                                     of arithmetic operations on 'glob' */
  static void *                   /* Loop 'arg' times incrementing 'glob' */
  threadFunc(void *arg)
  {
      int loops = *((int *) arg);
      int loc, j;

      for (j = 0; j < loops; j++) {
          loc = glob;
          loc++;
          glob = loc;
      }

      return NULL;
  }
  int
  main(int argc, char *argv[])
  {
      pthread_t t1, t2;
      int loops, s;

      loops = (argc > 1) ? getInt(argv[1], GN_GT_0, "num-loops") : 10000000;

      s = pthread_create(&t1, NULL, threadFunc, &loops);
      if (s != 0)
          errExitEN(s, "pthread_create");
      s = pthread_create(&t2, NULL, threadFunc, &loops);
      if (s != 0)
          errExitEN(s, "pthread_create");

      s = pthread_join(t1, NULL);
      if (s != 0)
          errExitEN(s, "pthread_join");
      s = pthread_join(t2, NULL);
      if (s != 0)
          errExitEN(s, "pthread_join");

      printf("glob = %d\n", glob);
      exit(EXIT_SUCCESS);
  }
#+END_SRC

#+RESULTS:
: - glob = 1107015

* 静态分配的互斥量

#+header: :cmdline "100" :includes <stdio.h> "/Users/c/Unix/error_functions.c" "/Users/c/Unix/get_num.c"
#+BEGIN_SRC C :results output list :exports both
  /**
   ,*
   ,* @copyright:
   ,* @file: 线程.org[*Org Src 线程.org[ C ]*]
   ,* @since: 2018-02-12
   ,* @author: czq | 7160844@qq.com
   ,* @description:
   ,*     使用互斥量保护全局变量的访问 
   ,* @usage:
   ,* @others:
   ,* @TODO:
   ,* @Revision History:
   ,* Date            Rel Ver.        Notes
   ,* 2018-02-12        1.0             开始创建
   ,*
   ,**/
  #include <pthread.h>
  #include "/Users/c/Unix/tlpi_hdr.h"

  static int glob = 0;
  static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

  static void *
  threadFunc(void *arg)
  {
      int loops = *((int *)arg);
      int loc, j, s;

      for (j = 0; j < loops; j++)
      {
          s = pthread_mutex_lock(&mtx);
          if (s != 0)
          {
              errExitEN(s, "pthread_mutex_lock");
          }

          loc = glob;
          loc++;
          glob = loc;

          s = pthread_mutex_unlock(&mtx);
          if (s != 0)
          {
              errExitEN(s, "pthread_mutex_unlock");
          }
      }

      return NULL;
  }

  int
  main(int argc, char *argv[])
  {
      pthread_t t1, t2;
      int loops, s;

      loops = (argc > 1) ? getInt(argv[1], GN_GT_0, "num-loops") : 1000000;

      s = pthread_create(&t1, NULL, threadFunc,&loops);
      if (s != 0)
      {
          errExitEN(s, "pthread_create");
      }

      s = pthread_create(&t2, NULL, threadFunc,&loops);
      if (s != 0)
      {
          errExitEN(s, "pthread_create");
      }

      s = pthread_join(t1, NULL);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      s = pthread_join(t2, NULL);
      if (s != 0)
      {
          errExitEN(s, "pthread_join");
      }

      printf("glob = %d\n", glob);
      exit(EXIT_SUCCESS);
  }
#+END_SRC

#+RESULTS:
: - glob = 200
